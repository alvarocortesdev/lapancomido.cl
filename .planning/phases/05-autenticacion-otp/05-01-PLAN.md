---
phase: 05-autenticacion-otp
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/prisma/schema.prisma
  - packages/database/prisma/seed.js
  - packages/database/package.json
  - apps/api/src/controllers/auth.controller.js
  - apps/api/src/routes/auth.routes.js
  - apps/api/src/routes/routes.js
  - apps/api/src/utils/validation.js
autonomous: true

must_haves:
  truths:
    - "Existen 2 usuarios predefinidos (dev y admin) en la base de datos"
    - "Usuario puede hacer login con username y password temporal"
    - "Primer login detecta setupRequired y pide email para validación OTP"
    - "Password policy enforces: 8+ chars, 1 número, 1 mayúscula, 1 minúscula, 1 especial"
  artifacts:
    - path: "packages/database/prisma/schema.prisma"
      provides: "users, otp_tokens, trusted_devices models"
      contains: "model users"
    - path: "packages/database/prisma/seed.js"
      provides: "Seed script para crear usuarios predefinidos con temp passwords"
      contains: "upsert"
    - path: "apps/api/src/controllers/auth.controller.js"
      provides: "Login endpoint con detección de setupRequired"
      exports: ["login", "initiateSetup", "verifySetupOTP", "completeSetup"]
    - path: "apps/api/src/utils/validation.js"
      provides: "Password strength validation"
      exports: ["validatePassword"]
  key_links:
    - from: "apps/api/src/controllers/auth.controller.js"
      to: "packages/database"
      via: "prisma.users.findUnique"
      pattern: "prisma\\.users\\.(findUnique|update)"
    - from: "apps/api/src/routes/routes.js"
      to: "apps/api/src/routes/auth.routes.js"
      via: "app.use('/auth')"
      pattern: "authRoutes"
---

<objective>
Crear la base de datos para autenticación admin y el flujo de primer login con validación OTP de email

Purpose: Establecer los modelos de datos y endpoints iniciales. El flujo de primer login requiere:
1. Usuario ingresa username + contraseña temporal
2. Sistema detecta setupRequired, pide email
3. Envía OTP de 8 dígitos (5 min) al email para validarlo
4. Usuario ingresa OTP + nueva contraseña (con política fuerte)
5. Vuelve al login para confirmar datos

Output:
- 3 nuevos modelos Prisma (users, otp_tokens, trusted_devices)
- Script de seed para usuarios dev/admin con contraseñas temporales
- Endpoints para flujo de setup con validación OTP
- Utilidad de validación de password con política fuerte
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-autenticacion-otp/05-RESEARCH.md
@.planning/phases/05-autenticacion-otp/05-CONTEXT.md
@packages/database/prisma/schema.prisma
@apps/api/src/middlewares/validateToken.js
@apps/api/src/controllers/contact.controller.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Agregar modelos de autenticación al schema Prisma</name>
  <files>
    packages/database/prisma/schema.prisma
    packages/database/package.json
  </files>
  <action>
Agregar 3 modelos al final del schema.prisma (después de quotation_leads):

1. **model users** con campos:
   - id: Int @id @default(autoincrement())
   - username: String @unique (para "dev" y "admin")
   - email: String? @unique
   - passwordHash: String? (contraseña temporal o definitiva)
   - tempPassword: String? (para primer login - se borra después)
   - role: String @default("admin") -- valores: "admin" o "developer"
   - passwordSetupRequired: Boolean @default(true)
   - otpAttempts: Int @default(0) (para tracking de intentos)
   - otpBlockedUntil: DateTime? (para bloqueo de 15 min)
   - createdAt: DateTime @default(now())
   - updatedAt: DateTime @default(now()) @updatedAt
   - Relaciones: otpTokens otp_tokens[], trustedDevices trusted_devices[]
   - @@schema("pancomido")

2. **model otp_tokens** con campos:
   - id: Int @id @default(autoincrement())
   - userId: Int
   - hashedCode: String
   - purpose: String @default("login") -- "login" | "setup" | "reset"
   - expiresAt: DateTime
   - used: Boolean @default(false)
   - createdAt: DateTime @default(now())
   - Relación: user users @relation(fields: [userId], references: [id], onDelete: Cascade)
   - @@index([userId, used, expiresAt])
   - @@schema("pancomido")

3. **model trusted_devices** con campos:
   - id: Int @id @default(autoincrement())
   - userId: Int
   - deviceToken: String @unique
   - userAgent: String?
   - ipAddress: String?
   - expiresAt: DateTime
   - lastUsedAt: DateTime @default(now())
   - createdAt: DateTime @default(now())
   - Relación: user users @relation(fields: [userId], references: [id], onDelete: Cascade)
   - @@index([userId, deviceToken])
   - @@schema("pancomido")

Agregar en package.json:
- Script "seed": "node prisma/seed.js"
- Key "prisma": { "seed": "node prisma/seed.js" }

Instalar uuid en packages/database:
```bash
cd packages/database && npm install uuid
```

Luego ejecutar:
```bash
npx prisma generate
npx prisma db push
```
  </action>
  <verify>
```bash
cd packages/database && npx prisma db push --accept-data-loss 2>&1 | grep -E "(created|Your database is now in sync)"
```
Debe mostrar que la base de datos está sincronizada y los modelos fueron creados.
  </verify>
  <done>Los modelos users, otp_tokens, y trusted_devices existen en la base de datos con campos para OTP attempts y blocking.</done>
</task>

<task type="auto">
  <name>Task 2: Crear seed script con contraseñas temporales</name>
  <files>
    packages/database/prisma/seed.js
  </files>
  <action>
Actualizar el seed.js existente para incluir usuarios admin. El archivo ya existe con datos de productos, agregar al final:

```javascript
// ============================================
// Admin Users (add after existing seed logic)
// ============================================

async function seedAdminUsers() {
  console.log('Seeding admin users...');
  
  const bcrypt = require('bcrypt');
  
  // Temporary passwords for first login (users must change these)
  const devTempPassword = await bcrypt.hash('dev2026!Temp', 10);
  const adminTempPassword = await bcrypt.hash('admin2026!Temp', 10);
  
  const devUser = await prisma.users.upsert({
    where: { username: 'dev' },
    update: {},
    create: {
      username: 'dev',
      role: 'developer',
      passwordHash: devTempPassword,
      tempPassword: 'dev2026!Temp', // Stored for reference, will be cleared after setup
      passwordSetupRequired: true
    }
  });
  
  const adminUser = await prisma.users.upsert({
    where: { username: 'admin' },
    update: {},
    create: {
      username: 'admin',
      role: 'admin',
      passwordHash: adminTempPassword,
      tempPassword: 'admin2026!Temp',
      passwordSetupRequired: true
    }
  });
  
  console.log('Seeded admin users:', { 
    dev: { id: devUser.id, username: devUser.username, role: devUser.role, tempPassword: 'dev2026!Temp' },
    admin: { id: adminUser.id, username: adminUser.username, role: adminUser.role, tempPassword: 'admin2026!Temp' }
  });
}

// Add to main() at the end:
// await seedAdminUsers();
```

Modificar la función main() del seed.js para llamar a seedAdminUsers() al final.

Ejecutar el seed:
```bash
cd packages/database && npm run seed
```
  </action>
  <verify>
```bash
cd packages/database && npm run seed 2>&1 | grep -E "Seeded (admin )?users"
```
Debe mostrar los 2 usuarios creados con sus IDs y contraseñas temporales.
  </verify>
  <done>Usuarios "dev" (role: developer) y "admin" (role: admin) existen con contraseñas temporales que funcionan para primer login.</done>
</task>

<task type="auto">
  <name>Task 3: Crear utilidad de validación de password y controller de auth</name>
  <files>
    apps/api/src/utils/validation.js
    apps/api/src/controllers/auth.controller.js
    apps/api/src/routes/auth.routes.js
    apps/api/src/routes/routes.js
  </files>
  <action>
**Crear apps/api/src/utils/validation.js:**

```javascript
// src/utils/validation.js

/**
 * Validate password strength per CONTEXT.md requirements:
 * - 8+ characters
 * - At least 1 number
 * - At least 1 uppercase letter
 * - At least 1 lowercase letter
 * - At least 1 special character
 * 
 * @returns {object} { valid: boolean, errors: string[] }
 */
function validatePassword(password) {
  const errors = [];
  
  if (!password || password.length < 8) {
    errors.push('Debe tener al menos 8 caracteres');
  }
  if (!/[0-9]/.test(password)) {
    errors.push('Debe incluir al menos 1 número');
  }
  if (!/[A-Z]/.test(password)) {
    errors.push('Debe incluir al menos 1 mayúscula');
  }
  if (!/[a-z]/.test(password)) {
    errors.push('Debe incluir al menos 1 minúscula');
  }
  if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
    errors.push('Debe incluir al menos 1 caracter especial (!@#$%^&*...)');
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Validate email format
 */
function validateEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

module.exports = {
  validatePassword,
  validateEmail
};
```

**Crear apps/api/src/controllers/auth.controller.js:**

```javascript
// src/controllers/auth.controller.js
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const prisma = require('@lapancomido/database');
const { validatePassword, validateEmail } = require('../utils/validation');

const SALT_ROUNDS = 10;
const JWT_EXPIRY = '30d';
const OTP_EXPIRY_MINUTES = 5; // Per CONTEXT.md
const OTP_MAX_ATTEMPTS = 3;
const OTP_BLOCK_MINUTES = 15;

/**
 * Generate 8-digit OTP (per CONTEXT.md)
 */
function generateOTP() {
  return crypto.randomInt(10000000, 99999999).toString();
}

/**
 * POST /auth/login
 * Step 1: Validate username + password (temp or real)
 * If setupRequired, return { setupRequired: true }
 * If normal login, proceed to device check (Plan 02)
 */
const login = async (req, res) => {
  try {
    const { username, password } = req.body;
    
    if (!username) {
      return res.status(400).json({ error: 'Username requerido' });
    }
    
    const user = await prisma.users.findUnique({
      where: { username }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Credenciales inválidas' });
    }
    
    // Password is required
    if (!password) {
      return res.status(400).json({ error: 'Contraseña requerida' });
    }
    
    // Verify password (temp or real)
    const isValid = await bcrypt.compare(password, user.passwordHash);
    if (!isValid) {
      return res.status(401).json({ error: 'Credenciales inválidas' });
    }
    
    // First-time setup required - need to validate email with OTP
    if (user.passwordSetupRequired) {
      return res.status(200).json({
        setupRequired: true,
        username: user.username,
        message: 'Primer inicio de sesión - ingresa tu email para validación'
      });
    }
    
    // Normal login - device check will be added in Plan 02
    // For now, return success with token
    const token = jwt.sign(
      { 
        userId: user.id, 
        role: user.role, 
        email: user.email,
        username: user.username
      },
      process.env.JWT_SECRET,
      { expiresIn: JWT_EXPIRY }
    );
    
    res.status(200).json({
      success: true,
      token,
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role
      }
    });
    
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};

/**
 * POST /auth/initiate-setup
 * Step 2: User provides email, we send OTP to validate it
 */
const initiateSetup = async (req, res) => {
  try {
    const { username, email } = req.body;
    
    if (!username || !email) {
      return res.status(400).json({ error: 'Username y email son requeridos' });
    }
    
    if (!validateEmail(email)) {
      return res.status(400).json({ error: 'Email inválido' });
    }
    
    const user = await prisma.users.findUnique({
      where: { username }
    });
    
    if (!user || !user.passwordSetupRequired) {
      return res.status(400).json({ error: 'Setup no disponible para este usuario' });
    }
    
    // Check if email already in use
    const existingEmail = await prisma.users.findUnique({
      where: { email }
    });
    if (existingEmail && existingEmail.id !== user.id) {
      return res.status(400).json({ error: 'Este email ya está en uso' });
    }
    
    // Check if user is blocked
    if (user.otpBlockedUntil && user.otpBlockedUntil > new Date()) {
      const waitMinutes = Math.ceil((user.otpBlockedUntil - new Date()) / 60000);
      return res.status(429).json({ 
        error: `Demasiados intentos. Espera ${waitMinutes} minutos.` 
      });
    }
    
    // Generate OTP (8 digits, 5 min expiry per CONTEXT.md)
    const otp = generateOTP();
    const hashedOTP = await bcrypt.hash(otp, SALT_ROUNDS);
    const expiresAt = new Date(Date.now() + OTP_EXPIRY_MINUTES * 60 * 1000);
    
    // Invalidate previous OTPs
    await prisma.otp_tokens.updateMany({
      where: { userId: user.id, used: false },
      data: { used: true }
    });
    
    // Create new OTP
    await prisma.otp_tokens.create({
      data: {
        userId: user.id,
        hashedCode: hashedOTP,
        purpose: 'setup',
        expiresAt,
        used: false
      }
    });
    
    // Temporarily save email (will be confirmed after OTP)
    await prisma.users.update({
      where: { id: user.id },
      data: { email }
    });
    
    // TODO: Send OTP via Resend (Plan 02)
    // For now, log it for development
    console.log(`[DEV] OTP for ${username}: ${otp}`);
    
    // Create pending token for next step
    const setupToken = jwt.sign(
      { userId: user.id, purpose: 'setup-otp', email },
      process.env.JWT_SECRET,
      { expiresIn: `${OTP_EXPIRY_MINUTES}m` }
    );
    
    res.status(200).json({
      success: true,
      setupToken,
      message: 'Código de verificación enviado a tu email',
      expiresIn: OTP_EXPIRY_MINUTES * 60 // seconds
    });
    
  } catch (error) {
    console.error('Initiate setup error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};

/**
 * POST /auth/verify-setup-otp
 * Step 3: Verify OTP for email validation
 */
const verifySetupOTP = async (req, res) => {
  try {
    const { setupToken, otp } = req.body;
    
    if (!setupToken || !otp) {
      return res.status(400).json({ error: 'Token y código OTP requeridos' });
    }
    
    // Validate OTP format (8 digits)
    if (!/^\d{8}$/.test(otp)) {
      return res.status(400).json({ error: 'Código debe ser de 8 dígitos' });
    }
    
    // Verify setup token
    let decoded;
    try {
      decoded = jwt.verify(setupToken, process.env.JWT_SECRET);
      if (decoded.purpose !== 'setup-otp') {
        throw new Error('Invalid token purpose');
      }
    } catch {
      return res.status(401).json({ error: 'Token expirado o inválido' });
    }
    
    const user = await prisma.users.findUnique({
      where: { id: decoded.userId }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Usuario no encontrado' });
    }
    
    // Check if blocked
    if (user.otpBlockedUntil && user.otpBlockedUntil > new Date()) {
      const waitMinutes = Math.ceil((user.otpBlockedUntil - new Date()) / 60000);
      return res.status(429).json({ 
        error: `Demasiados intentos. Espera ${waitMinutes} minutos.` 
      });
    }
    
    // Find valid OTP
    const otpToken = await prisma.otp_tokens.findFirst({
      where: {
        userId: user.id,
        purpose: 'setup',
        used: false,
        expiresAt: { gt: new Date() }
      },
      orderBy: { createdAt: 'desc' }
    });
    
    if (!otpToken) {
      return res.status(401).json({ error: 'Código expirado. Solicita uno nuevo.' });
    }
    
    // Verify OTP
    const isValid = await bcrypt.compare(otp, otpToken.hashedCode);
    
    if (!isValid) {
      // Increment attempts
      const newAttempts = user.otpAttempts + 1;
      const updateData = { otpAttempts: newAttempts };
      
      // Block after 3 attempts (per CONTEXT.md)
      if (newAttempts >= OTP_MAX_ATTEMPTS) {
        updateData.otpBlockedUntil = new Date(Date.now() + OTP_BLOCK_MINUTES * 60 * 1000);
        updateData.otpAttempts = 0;
        
        await prisma.users.update({
          where: { id: user.id },
          data: updateData
        });
        
        return res.status(429).json({ 
          error: `Código incorrecto. Has sido bloqueado por ${OTP_BLOCK_MINUTES} minutos.` 
        });
      }
      
      await prisma.users.update({
        where: { id: user.id },
        data: updateData
      });
      
      const remaining = OTP_MAX_ATTEMPTS - newAttempts;
      return res.status(401).json({ 
        error: `Código incorrecto, te quedan ${remaining} intento${remaining === 1 ? '' : 's'}`,
        hint: 'Revisa tu bandeja de spam'
      });
    }
    
    // OTP valid - mark as used and reset attempts
    await prisma.otp_tokens.update({
      where: { id: otpToken.id },
      data: { used: true }
    });
    
    await prisma.users.update({
      where: { id: user.id },
      data: { otpAttempts: 0, otpBlockedUntil: null }
    });
    
    // Create token for password setup step
    const passwordSetupToken = jwt.sign(
      { userId: user.id, purpose: 'password-setup', emailVerified: true },
      process.env.JWT_SECRET,
      { expiresIn: '10m' } // 10 minutes to set password
    );
    
    res.status(200).json({
      success: true,
      passwordSetupToken,
      message: 'Email verificado. Ahora configura tu contraseña.'
    });
    
  } catch (error) {
    console.error('Verify setup OTP error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};

/**
 * POST /auth/complete-setup
 * Step 4: Set new password and complete setup
 */
const completeSetup = async (req, res) => {
  try {
    const { passwordSetupToken, password, confirmPassword } = req.body;
    
    if (!passwordSetupToken || !password || !confirmPassword) {
      return res.status(400).json({ error: 'Todos los campos son requeridos' });
    }
    
    if (password !== confirmPassword) {
      return res.status(400).json({ error: 'Las contraseñas no coinciden' });
    }
    
    // Validate password strength
    const passwordValidation = validatePassword(password);
    if (!passwordValidation.valid) {
      return res.status(400).json({ 
        error: 'Contraseña no cumple los requisitos',
        details: passwordValidation.errors
      });
    }
    
    // Verify token
    let decoded;
    try {
      decoded = jwt.verify(passwordSetupToken, process.env.JWT_SECRET);
      if (decoded.purpose !== 'password-setup' || !decoded.emailVerified) {
        throw new Error('Invalid token');
      }
    } catch {
      return res.status(401).json({ error: 'Token expirado. Inicia el proceso nuevamente.' });
    }
    
    const user = await prisma.users.findUnique({
      where: { id: decoded.userId }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Usuario no encontrado' });
    }
    
    // Hash new password and complete setup
    const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);
    
    await prisma.users.update({
      where: { id: user.id },
      data: {
        passwordHash,
        tempPassword: null, // Clear temp password
        passwordSetupRequired: false
      }
    });
    
    // Don't issue token here - per CONTEXT.md, user should return to login
    res.status(200).json({
      success: true,
      message: 'Contraseña configurada exitosamente. Por favor inicia sesión.',
      redirectTo: '/login'
    });
    
  } catch (error) {
    console.error('Complete setup error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};

module.exports = {
  login,
  initiateSetup,
  verifySetupOTP,
  completeSetup
};
```

**Crear apps/api/src/routes/auth.routes.js:**

```javascript
// src/routes/auth.routes.js
const express = require('express');
const router = express.Router();
const authController = require('../controllers/auth.controller');

// POST /auth/login - Login with username/password
router.post('/login', authController.login);

// POST /auth/initiate-setup - Start first-time setup (sends OTP to email)
router.post('/initiate-setup', authController.initiateSetup);

// POST /auth/verify-setup-otp - Verify OTP for email validation
router.post('/verify-setup-otp', authController.verifySetupOTP);

// POST /auth/complete-setup - Set new password and complete setup
router.post('/complete-setup', authController.completeSetup);

module.exports = router;
```

**Actualizar apps/api/src/routes/routes.js** para incluir las rutas de auth:

Agregar al inicio con los otros requires:
```javascript
const authRoutes = require('./auth.routes');
```

Agregar antes de los otros app.use():
```javascript
app.use('/auth', authRoutes);
```
  </action>
  <verify>
```bash
# Verify validation utility
node -e "
const { validatePassword } = require('./apps/api/src/utils/validation.js');
console.log('Valid password:', validatePassword('Test123!@').valid);
console.log('Invalid password:', validatePassword('weak').valid, validatePassword('weak').errors);
"

# Verify controller exports
node -e "
const auth = require('./apps/api/src/controllers/auth.controller.js');
console.log('Controller exports:', Object.keys(auth).join(', '));
"

# Verify routes
grep -E "router\.(post|get)" apps/api/src/routes/auth.routes.js
```
  </verify>
  <done>
- POST /auth/login detecta setupRequired para primer login
- POST /auth/initiate-setup envía OTP de 8 dígitos al email
- POST /auth/verify-setup-otp valida OTP con 3 intentos / 15 min bloqueo
- POST /auth/complete-setup establece contraseña con política fuerte
- Usuario vuelve al login después de completar setup (no entra directo)
  </done>
</task>

</tasks>

<verification>
```bash
# Verify database models exist
cd packages/database && npx prisma db pull --print 2>&1 | grep -E "model (users|otp_tokens|trusted_devices)"

# Verify seed ran successfully
cd packages/database && node -e "
const prisma = require('./src/generated/client');
const p = new prisma.PrismaClient();
p.users.findMany().then(u => {
  console.log('Users in DB:', u.length);
  u.forEach(x => console.log('  -', x.username, x.role, 'setupRequired:', x.passwordSetupRequired));
  p.\$disconnect();
}).catch(e => { console.error(e); p.\$disconnect(); });
"

# Verify auth routes registered
grep -r "authRoutes" apps/api/src/routes/routes.js
```
</verification>

<success_criteria>
1. Prisma schema tiene modelos users (con otpAttempts, otpBlockedUntil), otp_tokens, trusted_devices
2. Base de datos tiene 2 usuarios con contraseñas temporales que funcionan
3. Password validation requiere: 8+ chars, número, mayúscula, minúscula, especial
4. POST /auth/login con username "dev" + temp password retorna {setupRequired: true}
5. Flujo completo: login → initiate-setup → verify-setup-otp → complete-setup → redirect to login
6. OTP es de 8 dígitos con 5 min de expiración
7. 3 intentos fallidos de OTP bloquean por 15 minutos
</success_criteria>

<output>
After completion, create `.planning/phases/05-autenticacion-otp/05-01-SUMMARY.md`
</output>
