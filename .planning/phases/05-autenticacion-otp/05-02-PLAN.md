---
phase: 05-autenticacion-otp
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/api/src/controllers/auth.controller.js
  - apps/api/src/services/auth.service.js
  - apps/api/src/routes/auth.routes.js
  - apps/api/package.json
autonomous: true
user_setup:
  - service: resend
    why: "OTP email delivery"
    env_vars:
      - name: RESEND_API_KEY
        source: "Already configured (used by contact form)"
    dashboard_config:
      - task: "Verify admin@lapancomido.cl sender for OTP emails"
        location: "Resend Dashboard -> Domains (already done for contacto@)"

must_haves:
  truths:
    - "Login desde dispositivo nuevo envía OTP de 8 dígitos por email"
    - "OTP expira en 5 minutos y tiene 3 intentos antes de bloqueo 15 min"
    - "Reenvío OTP: 1ro inmediato, 2do espera 15s, 3ro+ espera 30s"
    - "Dispositivo confiable usa cookie httpOnly (no localStorage)"
    - "Cookie de device trust dura 30 días"
  artifacts:
    - path: "apps/api/src/services/auth.service.js"
      provides: "OTP generation, email sending, device trust via cookies"
      exports: ["generateOTP", "sendOTPEmail", "createTrustedDevice", "isDeviceTrusted", "getResendCooldown"]
    - path: "apps/api/src/controllers/auth.controller.js"
      provides: "Extended auth endpoints with OTP flow for normal login"
      exports: ["login", "initiateSetup", "verifySetupOTP", "completeSetup", "verifyLoginOTP", "resendOTP"]
  key_links:
    - from: "apps/api/src/controllers/auth.controller.js"
      to: "apps/api/src/services/auth.service.js"
      via: "authService.generateOTP, sendOTPEmail"
      pattern: "authService\\.(generateOTP|sendOTPEmail|createTrustedDevice)"
    - from: "apps/api/src/services/auth.service.js"
      to: "resend"
      via: "Resend SDK emails.send"
      pattern: "resend\\.emails\\.send"
    - from: "res.cookie"
      to: "trusted device token"
      via: "httpOnly secure cookie"
      pattern: "res\\.cookie.*httpOnly.*true"
---

<objective>
Implementar el flujo OTP para login normal con device trust via cookies httpOnly

Purpose: Cuando un usuario con contraseña configurada hace login desde un dispositivo nuevo, el sistema:
1. Genera OTP de 8 dígitos con 5 min de expiración
2. Envía por email vía Resend
3. Permite 3 intentos antes de bloqueo 15 min
4. Gestiona reenvíos con cooldowns progresivos
5. Guarda dispositivo confiable en cookie httpOnly (30 días)

Output:
- auth.service.js con funciones de OTP, email y device trust
- Endpoints /auth/verify-login-otp y /auth/resend-otp
- Flujo login modificado para detectar dispositivos nuevos via cookie
- Device trust via httpOnly cookie (no localStorage)
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-autenticacion-otp/05-RESEARCH.md
@.planning/phases/05-autenticacion-otp/05-CONTEXT.md
@.planning/phases/05-autenticacion-otp/05-01-SUMMARY.md
@apps/api/src/controllers/auth.controller.js
@apps/api/src/controllers/contact.controller.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Crear auth.service.js con lógica de OTP, email y device trust</name>
  <files>
    apps/api/src/services/auth.service.js
    apps/api/package.json
  </files>
  <action>
**Instalar uuid en apps/api:**
```bash
cd apps/api && npm install uuid
```

**Crear apps/api/src/services/auth.service.js:**

```javascript
// src/services/auth.service.js
const crypto = require('crypto');
const bcrypt = require('bcrypt');
const { v4: uuidv4 } = require('uuid');
const { Resend } = require('resend');
const prisma = require('@lapancomido/database');

// Lazy Resend initialization (same pattern as contact.controller.js)
let resendInstance = null;
const getResend = () => {
  if (!resendInstance) {
    const apiKey = process.env.RESEND_API_KEY;
    if (!apiKey) return null;
    resendInstance = new Resend(apiKey);
  }
  return resendInstance;
};

// Constants per CONTEXT.md
const OTP_EXPIRY_MINUTES = 5;
const OTP_DIGITS = 8;
const OTP_MAX_ATTEMPTS = 3;
const OTP_BLOCK_MINUTES = 15;
const DEVICE_EXPIRY_DAYS = 30;
const MAX_TRUSTED_DEVICES = 5;
const SALT_ROUNDS = 10;

// Resend cooldowns per CONTEXT.md: 1st immediate, 2nd 15s, 3rd+ 30s
const RESEND_COOLDOWNS = [0, 15, 30]; // seconds

/**
 * Generate 8-digit OTP (per CONTEXT.md)
 */
function generateOTP() {
  const min = Math.pow(10, OTP_DIGITS - 1);
  const max = Math.pow(10, OTP_DIGITS) - 1;
  return crypto.randomInt(min, max + 1).toString();
}

/**
 * Get resend cooldown in seconds based on attempt number
 * @param {number} resendCount - Number of resends already done (0-based)
 */
function getResendCooldown(resendCount) {
  if (resendCount >= RESEND_COOLDOWNS.length) {
    return RESEND_COOLDOWNS[RESEND_COOLDOWNS.length - 1];
  }
  return RESEND_COOLDOWNS[resendCount];
}

/**
 * Create and store a hashed OTP for a user
 * @param {number} userId
 * @param {string} purpose - 'login' | 'setup'
 * @returns {string} The plain OTP (to be sent via email)
 */
async function createOTPToken(userId, purpose = 'login') {
  const otp = generateOTP();
  const hashedCode = await bcrypt.hash(otp, SALT_ROUNDS);
  const expiresAt = new Date(Date.now() + OTP_EXPIRY_MINUTES * 60 * 1000);
  
  // Invalidate any existing unused OTPs for this user with same purpose
  await prisma.otp_tokens.updateMany({
    where: { userId, purpose, used: false },
    data: { used: true }
  });
  
  // Create new OTP token
  await prisma.otp_tokens.create({
    data: {
      userId,
      hashedCode,
      purpose,
      expiresAt,
      used: false
    }
  });
  
  return otp;
}

/**
 * Verify an OTP for a user (timing-safe via bcrypt.compare)
 * @returns {{ valid: boolean, attemptsRemaining?: number, blocked?: boolean }}
 */
async function verifyOTPToken(userId, inputOTP, purpose = 'login') {
  const user = await prisma.users.findUnique({
    where: { id: userId }
  });
  
  if (!user) {
    return { valid: false };
  }
  
  // Check if blocked
  if (user.otpBlockedUntil && user.otpBlockedUntil > new Date()) {
    return { valid: false, blocked: true };
  }
  
  // Find valid OTP
  const token = await prisma.otp_tokens.findFirst({
    where: { 
      userId, 
      purpose,
      used: false, 
      expiresAt: { gt: new Date() } 
    },
    orderBy: { createdAt: 'desc' }
  });
  
  if (!token) {
    return { valid: false, expired: true };
  }
  
  const isValid = await bcrypt.compare(inputOTP, token.hashedCode);
  
  if (isValid) {
    // Mark as used and reset attempts
    await prisma.otp_tokens.update({
      where: { id: token.id },
      data: { used: true }
    });
    
    await prisma.users.update({
      where: { id: userId },
      data: { otpAttempts: 0, otpBlockedUntil: null }
    });
    
    return { valid: true };
  }
  
  // Invalid - increment attempts
  const newAttempts = user.otpAttempts + 1;
  const updateData = { otpAttempts: newAttempts };
  
  if (newAttempts >= OTP_MAX_ATTEMPTS) {
    updateData.otpBlockedUntil = new Date(Date.now() + OTP_BLOCK_MINUTES * 60 * 1000);
    updateData.otpAttempts = 0;
    
    await prisma.users.update({
      where: { id: userId },
      data: updateData
    });
    
    return { valid: false, blocked: true, justBlocked: true };
  }
  
  await prisma.users.update({
    where: { id: userId },
    data: updateData
  });
  
  return { 
    valid: false, 
    attemptsRemaining: OTP_MAX_ATTEMPTS - newAttempts 
  };
}

/**
 * Send OTP email via Resend
 */
async function sendOTPEmail(email, otp, username, purpose = 'login') {
  const resend = getResend();
  
  if (!resend) {
    console.warn('RESEND_API_KEY not configured - OTP email disabled');
    // In dev, just log the OTP
    console.log(`[DEV] OTP for ${username} (${purpose}): ${otp}`);
    return { id: 'dev-mode' };
  }
  
  const fromEmail = process.env.RESEND_FROM_EMAIL || 'La Pan Comido <onboarding@resend.dev>';
  const subjectPrefix = purpose === 'setup' ? 'Configura tu cuenta' : 'Código de verificación';
  
  const { data, error } = await resend.emails.send({
    from: fromEmail,
    to: [email],
    subject: `${subjectPrefix} - La Pan Comido Admin`,
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #262011; border-bottom: 2px solid #F5E1A4; padding-bottom: 10px;">
          ${purpose === 'setup' ? 'Verifica tu Email' : 'Código de Verificación'}
        </h2>
        
        <p>Hola ${username},</p>
        
        <p>${purpose === 'setup' 
          ? 'Usa este código para verificar tu email y completar la configuración de tu cuenta.'
          : 'Recibimos una solicitud de inicio de sesión desde un nuevo dispositivo.'
        }</p>
        
        <div style="background-color: #f9f9f9; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center;">
          <p style="margin: 0; font-size: 14px; color: #666;">Tu código de verificación:</p>
          <p style="font-size: 36px; font-weight: bold; letter-spacing: 4px; margin: 10px 0; color: #262011; font-family: monospace;">
            ${otp}
          </p>
          <p style="margin: 0; font-size: 12px; color: #999;">
            Este código expira en ${OTP_EXPIRY_MINUTES} minutos
          </p>
        </div>
        
        <p style="color: #666; font-size: 14px;">
          Si no solicitaste este código, ignora este correo.
        </p>
        
        <hr style="border: none; border-top: 1px solid #ddd; margin: 20px 0;">
        <p style="color: #666; font-size: 12px;">
          La Pan Comido - Panel de Administración
        </p>
      </div>
    `
  });
  
  if (error) {
    console.error('Resend OTP error:', error);
    throw new Error('Error al enviar email de verificación');
  }
  
  console.log('OTP email sent to:', email, 'Resend ID:', data?.id);
  return data;
}

/**
 * Check if a device is trusted via cookie
 * @param {number} userId
 * @param {string} deviceToken - Token from httpOnly cookie
 */
async function isDeviceTrusted(userId, deviceToken) {
  if (!deviceToken) return false;
  
  const device = await prisma.trusted_devices.findFirst({
    where: {
      userId,
      deviceToken,
      expiresAt: { gt: new Date() }
    }
  });
  
  if (device) {
    // Update last used timestamp
    await prisma.trusted_devices.update({
      where: { id: device.id },
      data: { lastUsedAt: new Date() }
    });
    return true;
  }
  
  return false;
}

/**
 * Create a trusted device after successful OTP verification
 * @returns {string} The device token to store in httpOnly cookie
 */
async function createTrustedDevice(userId, userAgent, ipAddress) {
  const deviceToken = uuidv4();
  const expiresAt = new Date(Date.now() + DEVICE_EXPIRY_DAYS * 24 * 60 * 60 * 1000);
  
  // Check device count and remove oldest if limit reached
  const deviceCount = await prisma.trusted_devices.count({
    where: { userId }
  });
  
  if (deviceCount >= MAX_TRUSTED_DEVICES) {
    // Delete oldest device
    const oldestDevice = await prisma.trusted_devices.findFirst({
      where: { userId },
      orderBy: { lastUsedAt: 'asc' }
    });
    if (oldestDevice) {
      await prisma.trusted_devices.delete({
        where: { id: oldestDevice.id }
      });
    }
  }
  
  // Create new trusted device
  await prisma.trusted_devices.create({
    data: {
      userId,
      deviceToken,
      userAgent: userAgent?.substring(0, 500),
      ipAddress,
      expiresAt,
      lastUsedAt: new Date()
    }
  });
  
  return deviceToken;
}

/**
 * Delete all trusted devices for a user (logout all sessions)
 */
async function revokeAllDevices(userId) {
  const result = await prisma.trusted_devices.deleteMany({
    where: { userId }
  });
  return result.count;
}

/**
 * Cookie options for device trust token
 */
const DEVICE_COOKIE_OPTIONS = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax',
  maxAge: DEVICE_EXPIRY_DAYS * 24 * 60 * 60 * 1000, // 30 days in ms
  path: '/'
};

const DEVICE_COOKIE_NAME = 'lpc_device_trust';

module.exports = {
  generateOTP,
  createOTPToken,
  verifyOTPToken,
  sendOTPEmail,
  isDeviceTrusted,
  createTrustedDevice,
  revokeAllDevices,
  getResendCooldown,
  DEVICE_COOKIE_OPTIONS,
  DEVICE_COOKIE_NAME,
  OTP_EXPIRY_MINUTES,
  OTP_MAX_ATTEMPTS,
  OTP_BLOCK_MINUTES,
  DEVICE_EXPIRY_DAYS
};
```
  </action>
  <verify>
```bash
# Verify service file exists and exports correctly
node -e "
const authService = require('./apps/api/src/services/auth.service.js');
console.log('Exports:', Object.keys(authService).join(', '));
console.log('Sample 8-digit OTP:', authService.generateOTP());
console.log('Resend cooldowns:', authService.getResendCooldown(0), authService.getResendCooldown(1), authService.getResendCooldown(2));
console.log('Cookie name:', authService.DEVICE_COOKIE_NAME);
"
```
Debe mostrar 8-digit OTP, cooldowns [0, 15, 30], y cookie name.
  </verify>
  <done>auth.service.js existe con OTP 8 dígitos, cooldowns progresivos, y configuración de cookie httpOnly.</done>
</task>

<task type="auto">
  <name>Task 2: Actualizar auth.controller.js con flujo OTP para login normal</name>
  <files>
    apps/api/src/controllers/auth.controller.js
    apps/api/src/routes/auth.routes.js
  </files>
  <action>
**Agregar funciones al auth.controller.js existente** (no reemplazar, agregar):

Al inicio, agregar import del service:
```javascript
const authService = require('../services/auth.service');
```

**Modificar la función login()** para usar cookies y detectar dispositivos:

```javascript
/**
 * POST /auth/login
 * Modified to check device trust via cookie and trigger OTP if needed
 */
const login = async (req, res) => {
  try {
    const { username, password } = req.body;
    
    if (!username) {
      return res.status(400).json({ error: 'Username requerido' });
    }
    
    const user = await prisma.users.findUnique({
      where: { username }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Credenciales inválidas' });
    }
    
    // Password is required
    if (!password) {
      return res.status(400).json({ error: 'Contraseña requerida' });
    }
    
    // Verify password (temp or real)
    const isValid = await bcrypt.compare(password, user.passwordHash);
    if (!isValid) {
      return res.status(401).json({ error: 'Credenciales inválidas' });
    }
    
    // First-time setup required
    if (user.passwordSetupRequired) {
      return res.status(200).json({
        setupRequired: true,
        username: user.username,
        message: 'Primer inicio de sesión - ingresa tu email para validación'
      });
    }
    
    // Check device trust via cookie
    const deviceToken = req.cookies?.[authService.DEVICE_COOKIE_NAME];
    const isTrusted = await authService.isDeviceTrusted(user.id, deviceToken);
    
    if (isTrusted) {
      // Trusted device - issue token directly
      const token = jwt.sign(
        { 
          userId: user.id, 
          role: user.role, 
          email: user.email,
          username: user.username
        },
        process.env.JWT_SECRET,
        { expiresIn: JWT_EXPIRY }
      );
      
      return res.status(200).json({
        success: true,
        token,
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          role: user.role
        }
      });
    }
    
    // New device - check if blocked
    if (user.otpBlockedUntil && user.otpBlockedUntil > new Date()) {
      const waitMinutes = Math.ceil((user.otpBlockedUntil - new Date()) / 60000);
      return res.status(429).json({ 
        error: `Demasiados intentos. Espera ${waitMinutes} minutos.` 
      });
    }
    
    // Send OTP
    try {
      const otp = await authService.createOTPToken(user.id, 'login');
      await authService.sendOTPEmail(user.email, otp, user.username, 'login');
      
      // Create pending token for OTP verification
      const otpPendingToken = jwt.sign(
        { userId: user.id, purpose: 'login-otp', resendCount: 0 },
        process.env.JWT_SECRET,
        { expiresIn: `${authService.OTP_EXPIRY_MINUTES}m` }
      );
      
      return res.status(200).json({
        otpRequired: true,
        otpPendingToken,
        email: maskEmail(user.email),
        expiresIn: authService.OTP_EXPIRY_MINUTES * 60,
        message: 'Código de verificación enviado a tu email'
      });
    } catch (emailError) {
      console.error('Failed to send OTP:', emailError);
      return res.status(500).json({ 
        error: 'Error al enviar código de verificación' 
      });
    }
    
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};
```

**Agregar nuevas funciones:**

```javascript
/**
 * POST /auth/verify-login-otp
 * Verify OTP for login, optionally trust device
 */
const verifyLoginOTP = async (req, res) => {
  try {
    const { otpPendingToken, otp, trustDevice } = req.body;
    
    if (!otpPendingToken || !otp) {
      return res.status(400).json({ error: 'Token y código OTP requeridos' });
    }
    
    // Validate OTP format (8 digits)
    if (!/^\d{8}$/.test(otp)) {
      return res.status(400).json({ error: 'Código debe ser de 8 dígitos' });
    }
    
    // Verify pending token
    let decoded;
    try {
      decoded = jwt.verify(otpPendingToken, process.env.JWT_SECRET);
      if (decoded.purpose !== 'login-otp') {
        throw new Error('Invalid token purpose');
      }
    } catch {
      return res.status(401).json({ error: 'Token expirado - inicia sesión nuevamente' });
    }
    
    // Verify OTP
    const result = await authService.verifyOTPToken(decoded.userId, otp, 'login');
    
    if (result.blocked) {
      if (result.justBlocked) {
        return res.status(429).json({ 
          error: `Código incorrecto. Has sido bloqueado por ${authService.OTP_BLOCK_MINUTES} minutos.` 
        });
      }
      return res.status(429).json({ 
        error: `Demasiados intentos. Intenta más tarde.` 
      });
    }
    
    if (result.expired) {
      return res.status(401).json({ error: 'Código expirado. Solicita uno nuevo.' });
    }
    
    if (!result.valid) {
      return res.status(401).json({ 
        error: `Código incorrecto, te quedan ${result.attemptsRemaining} intento${result.attemptsRemaining === 1 ? '' : 's'}`,
        hint: 'Revisa tu bandeja de spam'
      });
    }
    
    // OTP valid - get user
    const user = await prisma.users.findUnique({
      where: { id: decoded.userId }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Usuario no encontrado' });
    }
    
    // Trust device if requested (per CONTEXT.md: checkbox explicit)
    if (trustDevice) {
      const userAgent = req.headers['user-agent'];
      const ipAddress = req.ip || req.connection?.remoteAddress;
      const deviceToken = await authService.createTrustedDevice(user.id, userAgent, ipAddress);
      
      // Set httpOnly cookie
      res.cookie(
        authService.DEVICE_COOKIE_NAME,
        deviceToken,
        authService.DEVICE_COOKIE_OPTIONS
      );
    }
    
    // Generate access token
    const token = jwt.sign(
      { 
        userId: user.id, 
        role: user.role, 
        email: user.email,
        username: user.username
      },
      process.env.JWT_SECRET,
      { expiresIn: JWT_EXPIRY }
    );
    
    res.status(200).json({
      success: true,
      token,
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role
      },
      deviceTrusted: !!trustDevice,
      message: trustDevice 
        ? 'Sesión iniciada. Dispositivo guardado por 30 días.' 
        : 'Sesión iniciada.'
    });
    
  } catch (error) {
    console.error('Verify login OTP error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};

/**
 * POST /auth/resend-otp
 * Resend OTP with progressive cooldowns per CONTEXT.md
 */
const resendOTP = async (req, res) => {
  try {
    const { otpPendingToken } = req.body;
    
    if (!otpPendingToken) {
      return res.status(400).json({ error: 'Token requerido' });
    }
    
    // Verify pending token
    let decoded;
    try {
      decoded = jwt.verify(otpPendingToken, process.env.JWT_SECRET);
      if (!['login-otp', 'setup-otp'].includes(decoded.purpose)) {
        throw new Error('Invalid token purpose');
      }
    } catch {
      return res.status(401).json({ error: 'Token expirado - inicia sesión nuevamente' });
    }
    
    const resendCount = decoded.resendCount || 0;
    const cooldown = authService.getResendCooldown(resendCount);
    
    // Note: Frontend should enforce cooldown UI, but we could add server-side tracking too
    
    const user = await prisma.users.findUnique({
      where: { id: decoded.userId }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Usuario no encontrado' });
    }
    
    // Check if blocked
    if (user.otpBlockedUntil && user.otpBlockedUntil > new Date()) {
      const waitMinutes = Math.ceil((user.otpBlockedUntil - new Date()) / 60000);
      return res.status(429).json({ 
        error: `Demasiados intentos. Espera ${waitMinutes} minutos.` 
      });
    }
    
    // Determine purpose from token
    const purpose = decoded.purpose === 'setup-otp' ? 'setup' : 'login';
    
    // Generate and send new OTP
    const otp = await authService.createOTPToken(user.id, purpose);
    await authService.sendOTPEmail(user.email, otp, user.username, purpose);
    
    // Create new pending token with incremented resend count
    const newOtpPendingToken = jwt.sign(
      { 
        userId: user.id, 
        purpose: decoded.purpose,
        resendCount: resendCount + 1,
        email: decoded.email
      },
      process.env.JWT_SECRET,
      { expiresIn: `${authService.OTP_EXPIRY_MINUTES}m` }
    );
    
    // Calculate next cooldown
    const nextCooldown = authService.getResendCooldown(resendCount + 1);
    
    res.status(200).json({
      success: true,
      otpPendingToken: newOtpPendingToken,
      email: maskEmail(user.email),
      message: 'Nuevo código enviado',
      nextResendIn: nextCooldown // seconds until next resend allowed
    });
    
  } catch (error) {
    console.error('Resend OTP error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};

/**
 * POST /auth/logout-all
 * Revoke all trusted devices for current user
 */
const logoutAll = async (req, res) => {
  try {
    // Requires authentication
    if (!req.user) {
      return res.status(401).json({ error: 'No autenticado' });
    }
    
    const count = await authService.revokeAllDevices(req.user.userId);
    
    // Clear current device cookie
    res.clearCookie(authService.DEVICE_COOKIE_NAME);
    
    res.status(200).json({
      success: true,
      message: `${count} dispositivo${count === 1 ? '' : 's'} desconectado${count === 1 ? '' : 's'}`
    });
    
  } catch (error) {
    console.error('Logout all error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};

/**
 * Mask email for display
 */
function maskEmail(email) {
  if (!email) return '';
  const [local, domain] = email.split('@');
  if (local.length <= 2) {
    return `${local[0]}***@${domain}`;
  }
  return `${local[0]}***${local[local.length - 1]}@${domain}`;
}
```

**Actualizar exports:**
```javascript
module.exports = {
  login,
  initiateSetup,
  verifySetupOTP,
  completeSetup,
  verifyLoginOTP,
  resendOTP,
  logoutAll
};
```

**Actualizar apps/api/src/routes/auth.routes.js:**

```javascript
// src/routes/auth.routes.js
const express = require('express');
const router = express.Router();
const rateLimit = require('express-rate-limit');
const authController = require('../controllers/auth.controller');
const { validateToken } = require('../middlewares/validateToken');

// Rate limiting for auth endpoints (3 attempts per 15 min per CONTEXT.md)
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // Allow some buffer for page refreshes, actual OTP attempts tracked in DB
  message: { 
    error: 'Demasiados intentos. Intenta de nuevo en 15 minutos.' 
  },
  standardHeaders: true,
  legacyHeaders: false
});

// First-time setup flow
router.post('/login', authLimiter, authController.login);
router.post('/initiate-setup', authLimiter, authController.initiateSetup);
router.post('/verify-setup-otp', authLimiter, authController.verifySetupOTP);
router.post('/complete-setup', authLimiter, authController.completeSetup);

// Normal login OTP flow
router.post('/verify-login-otp', authLimiter, authController.verifyLoginOTP);
router.post('/resend-otp', authLimiter, authController.resendOTP);

// Session management (requires auth)
router.post('/logout-all', validateToken, authController.logoutAll);

module.exports = router;
```

**IMPORTANTE: Agregar cookie-parser al API si no existe:**
```bash
cd apps/api && npm install cookie-parser
```

En apps/api/src/app.js o donde se configura express, agregar:
```javascript
const cookieParser = require('cookie-parser');
app.use(cookieParser());
```
  </action>
  <verify>
```bash
# Verify controller exports
node -e "
const authController = require('./apps/api/src/controllers/auth.controller.js');
console.log('Controller exports:', Object.keys(authController).join(', '));
"

# Verify routes
grep -E "router\.(post|get)" apps/api/src/routes/auth.routes.js

# Verify cookie-parser installed
grep "cookie-parser" apps/api/package.json
```
Debe mostrar 7 exports, 7 rutas POST, y cookie-parser en dependencies.
  </verify>
  <done>
- POST /auth/login detecta dispositivo via cookie y envía OTP si nuevo
- POST /auth/verify-login-otp verifica OTP con checkbox para confiar dispositivo
- POST /auth/resend-otp con cooldowns progresivos (0s, 15s, 30s)
- POST /auth/logout-all revoca todos los dispositivos
- Device trust via cookie httpOnly (30 días)
- OTP: 8 dígitos, 5 min expiry, 3 intentos / 15 min bloqueo
  </done>
</task>

</tasks>

<verification>
```bash
# Verify service and controller work together
node -e "
const authService = require('./apps/api/src/services/auth.service.js');
const authController = require('./apps/api/src/controllers/auth.controller.js');
console.log('Service OTP:', authService.generateOTP().length, 'digits');
console.log('Cookie config:', authService.DEVICE_COOKIE_NAME, authService.DEVICE_COOKIE_OPTIONS.httpOnly);
console.log('Controller ready:', Object.keys(authController).length, 'functions');
"

# Full test requires running API
```
</verification>

<success_criteria>
1. auth.service.js genera OTP de 8 dígitos con 5 min expiración
2. Resend cooldowns funcionan: 1ro inmediato, 2do 15s, 3ro+ 30s
3. POST /auth/login usa cookie para detectar dispositivo confiable
4. POST /auth/verify-login-otp acepta trustDevice boolean y setea cookie httpOnly
5. POST /auth/logout-all revoca todos los dispositivos y limpia cookie
6. cookie-parser instalado y configurado
</success_criteria>

<output>
After completion, create `.planning/phases/05-autenticacion-otp/05-02-SUMMARY.md`
</output>
