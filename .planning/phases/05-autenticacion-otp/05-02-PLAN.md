---
phase: 05-autenticacion-otp
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/api/src/controllers/auth.controller.js
  - apps/api/src/services/auth.service.js
  - apps/api/src/routes/auth.routes.js
  - apps/api/package.json
autonomous: true
user_setup:
  - service: resend
    why: "OTP email delivery"
    env_vars:
      - name: RESEND_API_KEY
        source: "Already configured (used by contact form)"
    dashboard_config:
      - task: "Verify lapancomido.cl domain for production emails"
        location: "Resend Dashboard -> Domains"

must_haves:
  truths:
    - "Login desde dispositivo nuevo envía OTP por email"
    - "OTP se envía vía Resend al email registrado"
    - "Usuario puede verificar OTP y crear dispositivo confiable"
    - "Usuario puede solicitar reenvío de OTP"
  artifacts:
    - path: "apps/api/src/services/auth.service.js"
      provides: "OTP generation, email sending, device trust management"
      exports: ["generateOTP", "sendOTPEmail", "createTrustedDevice", "isDeviceTrusted"]
    - path: "apps/api/src/controllers/auth.controller.js"
      provides: "Extended auth endpoints with OTP flow"
      exports: ["login", "setupPassword", "verifyOTP", "resendOTP"]
  key_links:
    - from: "apps/api/src/controllers/auth.controller.js"
      to: "apps/api/src/services/auth.service.js"
      via: "authService.generateOTP, sendOTPEmail"
      pattern: "authService\\.(generateOTP|sendOTPEmail|createTrustedDevice)"
    - from: "apps/api/src/services/auth.service.js"
      to: "resend"
      via: "Resend SDK emails.send"
      pattern: "resend\\.emails\\.send"
    - from: "apps/api/src/services/auth.service.js"
      to: "prisma.otp_tokens"
      via: "database storage"
      pattern: "prisma\\.otp_tokens\\.(create|findFirst|update)"
---

<objective>
Implementar el flujo completo de OTP para verificación de dispositivos nuevos

Purpose: Cuando un usuario con contraseña configurada hace login desde un dispositivo nuevo (no confiable), el sistema genera un OTP de 6 dígitos, lo envía por email vía Resend, y solo permite acceso tras verificación exitosa. Dispositivos verificados se marcan como confiables.

Output:
- Servicio auth.service.js con funciones de OTP y device trust
- Endpoints /auth/verify-otp y /auth/resend-otp
- Flujo login modificado para detectar dispositivos nuevos
- Rate limiting en endpoints de auth
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-autenticacion-otp/05-RESEARCH.md
@.planning/phases/05-autenticacion-otp/05-01-SUMMARY.md
@apps/api/src/controllers/auth.controller.js
@apps/api/src/controllers/contact.controller.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Crear auth.service.js con lógica de OTP y device trust</name>
  <files>
    apps/api/src/services/auth.service.js
    apps/api/package.json
  </files>
  <action>
**Instalar uuid en apps/api:**
```bash
cd apps/api && npm install uuid
```

**Crear apps/api/src/services/auth.service.js:**

```javascript
// src/services/auth.service.js
const crypto = require('crypto');
const bcrypt = require('bcrypt');
const { v4: uuidv4 } = require('uuid');
const { Resend } = require('resend');
const prisma = require('@lapancomido/database');

// Lazy Resend initialization (same pattern as contact.controller.js)
let resendInstance = null;
const getResend = () => {
  if (!resendInstance) {
    const apiKey = process.env.RESEND_API_KEY;
    if (!apiKey) return null;
    resendInstance = new Resend(apiKey);
  }
  return resendInstance;
};

const OTP_EXPIRY_MINUTES = 10;
const DEVICE_EXPIRY_DAYS = 30;
const MAX_TRUSTED_DEVICES = 5;
const SALT_ROUNDS = 10;

/**
 * Generate a cryptographically secure 6-digit OTP
 */
function generateOTP() {
  return crypto.randomInt(100000, 999999).toString();
}

/**
 * Create and store a hashed OTP for a user
 * @returns {string} The plain OTP (to be sent via email)
 */
async function createOTPToken(userId) {
  const otp = generateOTP();
  const hashedCode = await bcrypt.hash(otp, SALT_ROUNDS);
  const expiresAt = new Date(Date.now() + OTP_EXPIRY_MINUTES * 60 * 1000);
  
  // Invalidate any existing unused OTPs for this user
  await prisma.otp_tokens.updateMany({
    where: { userId, used: false },
    data: { used: true }
  });
  
  // Create new OTP token
  await prisma.otp_tokens.create({
    data: {
      userId,
      hashedCode,
      expiresAt,
      used: false
    }
  });
  
  return otp;
}

/**
 * Verify an OTP for a user (timing-safe via bcrypt.compare)
 * @returns {boolean} Whether the OTP is valid
 */
async function verifyOTPToken(userId, inputOTP) {
  const token = await prisma.otp_tokens.findFirst({
    where: { 
      userId, 
      used: false, 
      expiresAt: { gt: new Date() } 
    },
    orderBy: { createdAt: 'desc' }
  });
  
  if (!token) return false;
  
  const isValid = await bcrypt.compare(inputOTP, token.hashedCode);
  
  if (isValid) {
    // Mark as used immediately
    await prisma.otp_tokens.update({
      where: { id: token.id },
      data: { used: true }
    });
  }
  
  return isValid;
}

/**
 * Send OTP email via Resend
 */
async function sendOTPEmail(email, otp, username) {
  const resend = getResend();
  
  if (!resend) {
    console.warn('RESEND_API_KEY not configured - OTP email disabled');
    throw new Error('Email service not configured');
  }
  
  const { data, error } = await resend.emails.send({
    from: 'La Pan Comido <onboarding@resend.dev>', // TODO: Change to verified domain
    to: [email],
    subject: 'Tu código de verificación - La Pan Comido Admin',
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #262011; border-bottom: 2px solid #F5E1A4; padding-bottom: 10px;">
          Código de Verificación
        </h2>
        
        <p>Hola ${username},</p>
        
        <p>Recibimos una solicitud de inicio de sesión desde un nuevo dispositivo.</p>
        
        <div style="background-color: #f9f9f9; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center;">
          <p style="margin: 0; font-size: 14px; color: #666;">Tu código de verificación:</p>
          <p style="font-size: 32px; font-weight: bold; letter-spacing: 8px; margin: 10px 0; color: #262011;">
            ${otp}
          </p>
          <p style="margin: 0; font-size: 12px; color: #999;">
            Este código expira en ${OTP_EXPIRY_MINUTES} minutos
          </p>
        </div>
        
        <p style="color: #666; font-size: 14px;">
          Si no solicitaste este código, ignora este correo.
        </p>
        
        <hr style="border: none; border-top: 1px solid #ddd; margin: 20px 0;">
        <p style="color: #666; font-size: 12px;">
          La Pan Comido - Panel de Administración
        </p>
      </div>
    `
  });
  
  if (error) {
    console.error('Resend OTP error:', error);
    throw new Error('Failed to send OTP email');
  }
  
  console.log('OTP email sent to:', email, 'Resend ID:', data?.id);
  return data;
}

/**
 * Check if a device is trusted for a user
 * @param {string} deviceToken - Token from client localStorage
 */
async function isDeviceTrusted(userId, deviceToken) {
  if (!deviceToken) return false;
  
  const device = await prisma.trusted_devices.findFirst({
    where: {
      userId,
      deviceToken,
      expiresAt: { gt: new Date() }
    }
  });
  
  if (device) {
    // Update last used timestamp
    await prisma.trusted_devices.update({
      where: { id: device.id },
      data: { lastUsedAt: new Date() }
    });
    return true;
  }
  
  return false;
}

/**
 * Create a trusted device after successful OTP verification
 * @returns {string} The device token to store in client localStorage
 */
async function createTrustedDevice(userId, userAgent, ipAddress) {
  const deviceToken = uuidv4();
  const expiresAt = new Date(Date.now() + DEVICE_EXPIRY_DAYS * 24 * 60 * 60 * 1000);
  
  // Check device count and remove oldest if limit reached
  const deviceCount = await prisma.trusted_devices.count({
    where: { userId }
  });
  
  if (deviceCount >= MAX_TRUSTED_DEVICES) {
    // Delete oldest device
    const oldestDevice = await prisma.trusted_devices.findFirst({
      where: { userId },
      orderBy: { lastUsedAt: 'asc' }
    });
    if (oldestDevice) {
      await prisma.trusted_devices.delete({
        where: { id: oldestDevice.id }
      });
    }
  }
  
  // Create new trusted device
  await prisma.trusted_devices.create({
    data: {
      userId,
      deviceToken,
      userAgent: userAgent?.substring(0, 500), // Limit length
      ipAddress,
      expiresAt,
      lastUsedAt: new Date()
    }
  });
  
  return deviceToken;
}

/**
 * Clean up expired OTPs and devices (can be called periodically)
 */
async function cleanupExpired() {
  const now = new Date();
  
  await prisma.otp_tokens.deleteMany({
    where: { expiresAt: { lt: now } }
  });
  
  await prisma.trusted_devices.deleteMany({
    where: { expiresAt: { lt: now } }
  });
}

module.exports = {
  generateOTP,
  createOTPToken,
  verifyOTPToken,
  sendOTPEmail,
  isDeviceTrusted,
  createTrustedDevice,
  cleanupExpired,
  OTP_EXPIRY_MINUTES
};
```
  </action>
  <verify>
```bash
# Verify service file exists and exports correctly
node -e "
const authService = require('./apps/api/src/services/auth.service.js');
console.log('Exports:', Object.keys(authService).join(', '));
console.log('generateOTP type:', typeof authService.generateOTP);
console.log('Sample OTP:', authService.generateOTP());
"
```
Debe mostrar las funciones exportadas y un OTP de ejemplo de 6 dígitos.
  </verify>
  <done>auth.service.js existe con funciones generateOTP, createOTPToken, verifyOTPToken, sendOTPEmail, isDeviceTrusted, createTrustedDevice.</done>
</task>

<task type="auto">
  <name>Task 2: Actualizar auth.controller.js con flujo OTP completo</name>
  <files>
    apps/api/src/controllers/auth.controller.js
    apps/api/src/routes/auth.routes.js
  </files>
  <action>
**Reemplazar completamente auth.controller.js** para incluir flujo OTP:

```javascript
// src/controllers/auth.controller.js
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const prisma = require('@lapancomido/database');
const authService = require('../services/auth.service');

const SALT_ROUNDS = 10;
const JWT_EXPIRY = '30d';

/**
 * POST /auth/login
 * Handles login with username/password
 * - If setupRequired: return setupRequired: true
 * - If device trusted: return token directly
 * - If device new: send OTP and return otpRequired: true
 */
const login = async (req, res) => {
  try {
    const { username, password, deviceToken } = req.body;
    
    if (!username) {
      return res.status(400).json({ error: 'Username requerido' });
    }
    
    const user = await prisma.users.findUnique({
      where: { username }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Credenciales inválidas' });
    }
    
    // First-time setup required
    if (user.passwordSetupRequired) {
      return res.status(200).json({
        setupRequired: true,
        username: user.username,
        message: 'Primer inicio de sesión - configura tu email y contraseña'
      });
    }
    
    // Normal login - verify password
    if (!password) {
      return res.status(400).json({ error: 'Contraseña requerida' });
    }
    
    const isValid = await bcrypt.compare(password, user.passwordHash);
    if (!isValid) {
      return res.status(401).json({ error: 'Credenciales inválidas' });
    }
    
    // Check if device is trusted
    const isTrusted = await authService.isDeviceTrusted(user.id, deviceToken);
    
    if (isTrusted) {
      // Trusted device - issue token directly
      const token = jwt.sign(
        { 
          userId: user.id, 
          role: user.role, 
          email: user.email,
          username: user.username
        },
        process.env.JWT_SECRET,
        { expiresIn: JWT_EXPIRY }
      );
      
      return res.status(200).json({
        success: true,
        token,
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          role: user.role
        }
      });
    }
    
    // New device - send OTP
    try {
      const otp = await authService.createOTPToken(user.id);
      await authService.sendOTPEmail(user.email, otp, user.username);
      
      // Store userId in a temporary way for OTP verification
      // We use a short-lived token that only allows OTP verification
      const otpPendingToken = jwt.sign(
        { userId: user.id, purpose: 'otp-verification' },
        process.env.JWT_SECRET,
        { expiresIn: `${authService.OTP_EXPIRY_MINUTES}m` }
      );
      
      return res.status(200).json({
        otpRequired: true,
        otpPendingToken,
        email: maskEmail(user.email),
        message: 'Código OTP enviado a tu email'
      });
    } catch (emailError) {
      console.error('Failed to send OTP:', emailError);
      return res.status(500).json({ 
        error: 'Error al enviar código de verificación' 
      });
    }
    
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};

/**
 * POST /auth/setup-password
 * First-time setup: set email and password
 */
const setupPassword = async (req, res) => {
  try {
    const { username, email, password } = req.body;
    
    if (!username || !email || !password) {
      return res.status(400).json({ 
        error: 'Username, email y password son requeridos' 
      });
    }
    
    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ error: 'Email inválido' });
    }
    
    // Validate password strength (min 8 chars)
    if (password.length < 8) {
      return res.status(400).json({ 
        error: 'La contraseña debe tener al menos 8 caracteres' 
      });
    }
    
    const user = await prisma.users.findUnique({
      where: { username }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Usuario no encontrado' });
    }
    
    if (!user.passwordSetupRequired) {
      return res.status(400).json({ 
        error: 'Este usuario ya tiene contraseña configurada' 
      });
    }
    
    // Check if email is already in use by another user
    const existingEmail = await prisma.users.findUnique({
      where: { email }
    });
    if (existingEmail && existingEmail.id !== user.id) {
      return res.status(400).json({ error: 'Este email ya está en uso' });
    }
    
    // Hash password and update user
    const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);
    
    await prisma.users.update({
      where: { id: user.id },
      data: {
        email,
        passwordHash,
        passwordSetupRequired: false
      }
    });
    
    // Create trusted device for this first login
    const userAgent = req.headers['user-agent'];
    const ipAddress = req.ip || req.connection?.remoteAddress;
    const deviceToken = await authService.createTrustedDevice(user.id, userAgent, ipAddress);
    
    // Generate token for immediate login
    const token = jwt.sign(
      { 
        userId: user.id, 
        role: user.role, 
        email,
        username: user.username
      },
      process.env.JWT_SECRET,
      { expiresIn: JWT_EXPIRY }
    );
    
    res.status(200).json({
      success: true,
      token,
      deviceToken, // Client should store this in localStorage
      user: {
        id: user.id,
        username: user.username,
        email,
        role: user.role
      },
      message: 'Contraseña configurada exitosamente'
    });
    
  } catch (error) {
    console.error('Setup password error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};

/**
 * POST /auth/verify-otp
 * Verify OTP and create trusted device
 */
const verifyOTP = async (req, res) => {
  try {
    const { otpPendingToken, otp } = req.body;
    
    if (!otpPendingToken || !otp) {
      return res.status(400).json({ 
        error: 'Token y código OTP son requeridos' 
      });
    }
    
    // Validate OTP format (6 digits)
    if (!/^\d{6}$/.test(otp)) {
      return res.status(400).json({ error: 'Código OTP inválido' });
    }
    
    // Verify the pending token
    let decoded;
    try {
      decoded = jwt.verify(otpPendingToken, process.env.JWT_SECRET);
      if (decoded.purpose !== 'otp-verification') {
        throw new Error('Invalid token purpose');
      }
    } catch {
      return res.status(401).json({ error: 'Token de verificación expirado o inválido' });
    }
    
    const userId = decoded.userId;
    
    // Verify OTP
    const isValid = await authService.verifyOTPToken(userId, otp);
    
    if (!isValid) {
      return res.status(401).json({ error: 'Código OTP incorrecto o expirado' });
    }
    
    // Get user data
    const user = await prisma.users.findUnique({
      where: { id: userId }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Usuario no encontrado' });
    }
    
    // Create trusted device
    const userAgent = req.headers['user-agent'];
    const ipAddress = req.ip || req.connection?.remoteAddress;
    const deviceToken = await authService.createTrustedDevice(userId, userAgent, ipAddress);
    
    // Generate full access token
    const token = jwt.sign(
      { 
        userId: user.id, 
        role: user.role, 
        email: user.email,
        username: user.username
      },
      process.env.JWT_SECRET,
      { expiresIn: JWT_EXPIRY }
    );
    
    res.status(200).json({
      success: true,
      token,
      deviceToken, // Client should store this in localStorage
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role
      },
      message: 'Dispositivo verificado exitosamente'
    });
    
  } catch (error) {
    console.error('Verify OTP error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};

/**
 * POST /auth/resend-otp
 * Resend OTP to user's email
 */
const resendOTP = async (req, res) => {
  try {
    const { otpPendingToken } = req.body;
    
    if (!otpPendingToken) {
      return res.status(400).json({ error: 'Token requerido' });
    }
    
    // Verify the pending token
    let decoded;
    try {
      decoded = jwt.verify(otpPendingToken, process.env.JWT_SECRET);
      if (decoded.purpose !== 'otp-verification') {
        throw new Error('Invalid token purpose');
      }
    } catch {
      return res.status(401).json({ error: 'Token expirado - inicia sesión nuevamente' });
    }
    
    const userId = decoded.userId;
    
    // Get user data
    const user = await prisma.users.findUnique({
      where: { id: userId }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Usuario no encontrado' });
    }
    
    // Generate and send new OTP
    try {
      const otp = await authService.createOTPToken(user.id);
      await authService.sendOTPEmail(user.email, otp, user.username);
      
      res.status(200).json({
        success: true,
        email: maskEmail(user.email),
        message: 'Nuevo código OTP enviado'
      });
    } catch (emailError) {
      console.error('Failed to resend OTP:', emailError);
      return res.status(500).json({ 
        error: 'Error al enviar código de verificación' 
      });
    }
    
  } catch (error) {
    console.error('Resend OTP error:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
};

/**
 * Mask email for display (e.g., "u***@gmail.com")
 */
function maskEmail(email) {
  if (!email) return '';
  const [local, domain] = email.split('@');
  if (local.length <= 2) {
    return `${local[0]}***@${domain}`;
  }
  return `${local[0]}***${local[local.length - 1]}@${domain}`;
}

module.exports = {
  login,
  setupPassword,
  verifyOTP,
  resendOTP
};
```

**Actualizar auth.routes.js** para incluir las nuevas rutas:

```javascript
// src/routes/auth.routes.js
const express = require('express');
const router = express.Router();
const rateLimit = require('express-rate-limit');
const authController = require('../controllers/auth.controller');

// Rate limiting for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts per window
  message: { 
    error: 'Demasiados intentos. Intenta de nuevo en 15 minutos.' 
  },
  standardHeaders: true,
  legacyHeaders: false
});

// POST /auth/login - Login with username/password
router.post('/login', authLimiter, authController.login);

// POST /auth/setup-password - First-time password setup
router.post('/setup-password', authLimiter, authController.setupPassword);

// POST /auth/verify-otp - Verify OTP code
router.post('/verify-otp', authLimiter, authController.verifyOTP);

// POST /auth/resend-otp - Resend OTP code
router.post('/resend-otp', authLimiter, authController.resendOTP);

module.exports = router;
```
  </action>
  <verify>
```bash
# Verify controller exports
node -e "
const authController = require('./apps/api/src/controllers/auth.controller.js');
console.log('Controller exports:', Object.keys(authController).join(', '));
"

# Verify routes file has all endpoints
grep -E "router\.(post|get)" apps/api/src/routes/auth.routes.js
```
Debe mostrar: login, setupPassword, verifyOTP, resendOTP en exports y 4 rutas POST.
  </verify>
  <done>
- POST /auth/login detecta dispositivo nuevo y envía OTP
- POST /auth/verify-otp verifica OTP y crea dispositivo confiable
- POST /auth/resend-otp permite reenviar OTP
- Rate limiting aplicado a todos los endpoints de auth (5 intentos / 15 min)
  </done>
</task>

</tasks>

<verification>
```bash
# Full integration test (requires RESEND_API_KEY in env)
# 1. Check API starts without errors
cd apps/api && timeout 3 npm run dev 2>&1 | grep -E "(listening|error)" &
sleep 2

# 2. Test login flow for user without password
curl -s -X POST http://localhost:3000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"dev"}' | jq .

# 3. Test rate limiting (6th request should fail)
for i in {1..6}; do
  curl -s -X POST http://localhost:3000/auth/login \
    -H "Content-Type: application/json" \
    -d '{"username":"invalid"}' | jq -r '.error // "ok"'
done

pkill -f "node.*api" 2>/dev/null || true
```
</verification>

<success_criteria>
1. auth.service.js exporta todas las funciones de OTP y device trust
2. POST /auth/login con password válido + sin deviceToken retorna {otpRequired: true, otpPendingToken: "..."}
3. POST /auth/verify-otp con OTP válido retorna {success: true, token: "...", deviceToken: "..."}
4. POST /auth/resend-otp regenera y envía nuevo OTP
5. Rate limiting bloquea después de 5 intentos en 15 minutos
</success_criteria>

<output>
After completion, create `.planning/phases/05-autenticacion-otp/05-02-SUMMARY.md`
</output>
